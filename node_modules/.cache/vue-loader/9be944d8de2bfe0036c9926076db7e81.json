{"remainingRequest":"/Users/chenmeiya/Desktop/程式（未整理）/mia_side_project/miachen_work/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/chenmeiya/Desktop/程式（未整理）/mia_side_project/miachen_work/src/components/Stairs/index.vue?vue&type=style&index=0&id=74c8cb06&lang=sass&scoped=true","dependencies":[{"path":"/Users/chenmeiya/Desktop/程式（未整理）/mia_side_project/miachen_work/src/components/Stairs/index.vue","mtime":1734525089643},{"path":"/Users/chenmeiya/Desktop/程式（未整理）/mia_side_project/miachen_work/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/chenmeiya/Desktop/程式（未整理）/mia_side_project/miachen_work/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/chenmeiya/Desktop/程式（未整理）/mia_side_project/miachen_work/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/chenmeiya/Desktop/程式（未整理）/mia_side_project/miachen_work/node_modules/sass-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/chenmeiya/Desktop/程式（未整理）/mia_side_project/miachen_work/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/chenmeiya/Desktop/程式（未整理）/mia_side_project/miachen_work/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CiNzdGFpcnMKICB3aWR0aDogMTAwJQogIGhlaWdodDogMTAwJQogIC5zZXR0aW5nCiAgICBkaXNwbGF5OiBmbGV4CiAgLnNldC1ib3gKICAgIHdpZHRoOiAzMCUKICAuc3RhaXJzLWJveAogICAgLy8gd2lkdGg6IDEwMCUKICAgIG1heC13aWR0aDogOTAwcHgK"},{"version":3,"sources":["index.vue"],"names":[],"mappings":";AAwSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/components/Stairs","sourcesContent":["<template lang=\"pug\">\n#stairs\n  .setting\n    .set-box.col-2\n      span 幾條路：\n      select(v-model=\"straight\")\n        option(v-for=\"item in straights\", :key=\"item.name\", :value=\"item.name\") {{ item.value }}\n    .set-box.col-2\n      span 幾個橫軸：\n      select(v-model=\"horizontal\")\n        option(\n          v-for=\"item in horizontals\",\n          :key=\"item.name\",\n          :value=\"item.name\"\n        ) {{ item.value }}\n    button(type=\"submit\", @click=\"createStairs\") 生成梯子\n  br\n  //- .btn-box\n  //-   button.btn(\n  //-     type=\"submit\",\n  //-     v-for=\"(item, idx) in straight\",\n  //-     :key=\"item.idx\",\n  //-     @click=\"getRoadPosition(item - 1)\"\n  //-   ) 第 {{ item }} 條路\n  .stairs-box(ref=\"stairsBox\")\n</template>\n<script>\n// import * as PIXI from \"pixi.js\";\nimport { mapState } from \"vuex\";\nimport * as PIXIBasic from \"../../unit/pixiBasic\";\nexport default {\n  data() {\n    return {\n      app: null,\n      loader: new this.PIXI.Loader(),\n      resources: null,\n      stairs_container: null,\n      road_container: null,\n      start_doll_container: null,\n      grey_filter: null,\n      road: null,\n      roadSetUp: () => {},\n      app_width: 900,\n      app_height: 600,\n      boundary: {\n        min_x: 100,\n        min_y: 50,\n        max_x: 800,\n        max_y: 550,\n      },\n      stairs_style: { width: 15, color: 0xb86741, alpha: 1 },\n      road_style: {\n        width: 20,\n        alignment: 0.5,\n        color: 0x48afa7,\n        alpha: 1,\n        join: \"round\",\n        miterLimit: 100,\n      },\n      road_position: [],\n      straights: [],\n      straight: 3,\n      straight_position: [],\n      horizontals: [],\n      horizontal: 8,\n      horizontal_position: [],\n      start_doll_name: [\"eggHead\", \"flowerTop\", \"helmlok\", \"skully\"],\n      is_start_doll_click: false,\n      start_doll_sprite: [],\n    };\n  },\n  mounted() {\n    this.init();\n  },\n  watch: {\n    straight: {\n      handler(val) {\n        this.horizontals = [];\n        for (let i = val - 1; i <= val + 3; i++)\n          this.horizontals.push({ value: i, name: i });\n        this.horizontal = this.horizontals[2].name;\n      },\n      immediate: true,\n    },\n    is_start_doll_click(is_click) {\n      this.start_doll_sprite.forEach((sprite) => {\n        let filters = [];\n        sprite.interactive = is_click;\n        if (!is_click) filters = [this.grey_filter];\n        sprite.filters = filters;\n      });\n    },\n  },\n  computed: {\n    ...mapState({ image_path: (state) => state.image_path }),\n  },\n  methods: {\n    init() {\n      this.straights = [];\n      for (let i = 3; i <= 5; i++)\n        this.straights.push({ value: `${i} 列`, name: i });\n      this.app = new this.PIXI.Application({\n        width: this.app_width,\n        height: this.app_height,\n        backgroundColor: 0xf7f2ea,\n      });\n      this.grey_filter = new this.PIXI.filters.ColorMatrixFilter();\n      this.grey_filter.greyscale(0.2);\n      this.stairs_container = new this.PIXI.Container();\n      this.road_container = new this.PIXI.Container();\n      this.start_doll_container = new this.PIXI.Container();\n      this.app.stage.addChild(\n        this.stairs_container,\n        this.road_container,\n        this.start_doll_container\n      );\n      this.$refs.stairsBox.appendChild(this.app.view);\n      this.resources = this.loader.resources;\n      this.loader\n        .add(\"eggHead\", this.image_path + \"assets/doll/eggHead.png\")\n        .add(\"flowerTop\", this.image_path + \"assets/doll/flowerTop.png\")\n        .add(\"helmlok\", this.image_path + \"assets/doll/helmlok.png\")\n        .add(\"skully\", this.image_path + \"assets/doll/skully.png\");\n      this.loader.load(() => {\n        this.createStairs();\n      });\n    },\n    createStairs() {\n      this.app.ticker.remove(this.roadSetUp);\n      this.horizontal_position = [];\n      this.stairs_container.removeChildren();\n      this.road_container.removeChildren();\n      this.start_doll_container.removeChildren();\n      this.start_doll_sprite.forEach((sprite) => sprite.destroyed);\n      this.start_doll_sprite = [];\n      const { min_x, min_y, max_y } = this.boundary;\n      const distance_x = Math.ceil(\n        (this.app_width - 2 * min_x) / (this.straight - 1)\n      );\n      this.straight_position = [];\n      let horizontal_start = [];\n      for (let i = 0; i < this.straight; i++) {\n        const x = min_x + distance_x * i;\n        this.initStartSprite(i, x);\n        this.straight_position.push({ x, y: min_y });\n        const straight = new this.PIXI.Graphics();\n        straight.lineStyle(this.stairs_style);\n        straight.moveTo(x, min_y);\n        straight.lineTo(x, max_y);\n        this.stairs_container.addChild(straight);\n      }\n      for (let i = 0; i < this.horizontal; i++) {\n        // const level = i % (this.straight - 1),\n        //   assign = (this.app_height - 200) / (this.straight - 1);\n        const random_x =\n          i < this.straight - 1\n            ? i\n            : Math.floor(Math.random() * (this.straight - 1));\n        const x = this.straight_position[random_x].x;\n        const last_point_x =\n            random_x > 0\n              ? this.straight_position[random_x - 1].x || null\n              : null,\n          next_point_x = this.straight_position[random_x + 1].x || null;\n        let random_y;\n\n        const getRandomY = () => {\n          random_y = Math.ceil(min_y + 50 + Math.random() * 400);\n          for (let j = 0; j < horizontal_start.length; j++) {\n            const { x: point_x, y: point_y } = horizontal_start[j];\n            if (\n              [x, last_point_x, next_point_x].includes(point_x) &&\n              random_y >= point_y - 50 &&\n              random_y <= point_y + 50\n            ) {\n              getRandomY();\n              break;\n            }\n          }\n        };\n        getRandomY();\n\n        const start_point = { x, y: random_y };\n        const horizontal = new this.PIXI.Graphics();\n        horizontal.lineStyle(this.stairs_style);\n        horizontal.moveTo(start_point.x, start_point.y);\n        horizontal.lineTo(distance_x + start_point.x, start_point.y);\n        horizontal_start.push({ x: start_point.x, y: start_point.y });\n        this.stairs_container.addChild(horizontal);\n      }\n      this.horizontal_position = horizontal_start.sort((a, b) => a.y - b.y);\n      this.is_start_doll_click = true;\n      // this.getRoadPosition();\n    },\n    initStartSprite(whitch_road, x) {\n      const start_doll = this.start_doll_name[whitch_road % 4];\n      const sprite = PIXIBasic.getPIXISprite(\n        this.resources[start_doll].texture,\n        x,\n        0\n      );\n      sprite.anchor.set(0.5, 0);\n      sprite.scale.set(0.4, 0.4);\n      sprite.cursor = \"pointer\";\n      sprite.on(\"pointerdown\", onClick);\n      const _this = this;\n      function onClick() {\n        _this.getRoadPosition(whitch_road);\n      }\n      this.start_doll_sprite.push(sprite);\n      sprite.interactive = true;\n      this.start_doll_container.addChild(sprite);\n    },\n    getRoadPosition(road) {\n      // if (this.road !== null) this.road.clear();\n      this.is_start_doll_click = false;\n      this.road_container.removeChildren();\n      let start_road = road;\n      this.road_position = [];\n      let { x: now_x, y: now_y } = this.straight_position[start_road];\n      this.road_position.push({ x: now_x, y: now_y });\n      this.horizontal_position.forEach(({ x: pos_x, y: pos_y }) => {\n        const last_x =\n          start_road === 0 ? null : this.straight_position[start_road - 1].x;\n        if (pos_y > now_y && [last_x, now_x].includes(pos_x)) {\n          // let next_x;\n          this.road_position.push({ x: now_x, y: pos_y });\n          if (pos_x === now_x) start_road += 1;\n          else if (pos_x === last_x) start_road -= 1;\n          this.road_position.push({\n            x: this.straight_position[start_road].x,\n            y: pos_y,\n          });\n          now_x = this.straight_position[start_road].x;\n        }\n      });\n      this.road_position.push({ x: now_x, y: this.boundary.max_y });\n\n      this.drawRoad();\n    },\n    drawRoad() {\n      // const start_road = 0;\n      this.road = new this.PIXI.Graphics();\n      this.road.lineStyle(this.road_style);\n      let count = 0,\n        now_x = this.road_position[count].x,\n        now_y = this.road_position[count].y,\n        next_x = now_x,\n        next_y = now_y;\n      this.roadSetUp = (delta) => {\n        const speed = 10 * delta;\n        const last_x_point = now_x;\n        this.road.moveTo(now_x, now_y);\n        if (\n          next_x === this.road_position[count].x &&\n          next_y === this.road_position[count].y\n        ) {\n          now_x = this.road_position[count].x;\n          now_y = this.road_position[count].y;\n          count++;\n        }\n        if (count >= this.road_position.length) {\n          this.app.ticker.remove(this.roadSetUp);\n          this.is_start_doll_click = true;\n          return;\n        }\n        const { x, y } = this.road_position[count];\n        this.road.lineTo(next_x, next_y);\n        if (last_x_point < x) {\n          next_x += speed;\n          if (next_x > x) {\n            next_x = x;\n          }\n        } else if (last_x_point > x) {\n          next_x -= speed;\n          if (next_x < x) {\n            next_x = x;\n          }\n        } else if (last_x_point === x && next_y === y) {\n          next_x = x;\n        }\n        if (next_y + speed >= y) {\n          next_y = y;\n        } else {\n          next_y += speed;\n        }\n        this.road.lineTo(next_x, next_y);\n      };\n      this.app.ticker.add(this.roadSetUp);\n      this.road.endFill();\n      this.road_container.addChild(this.road);\n    },\n  },\n};\n</script>\n<style lang=\"sass\" scoped>\n#stairs\n  width: 100%\n  height: 100%\n  .setting\n    display: flex\n  .set-box\n    width: 30%\n  .stairs-box\n    // width: 100%\n    max-width: 900px\n</style>"]}]}